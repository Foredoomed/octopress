---
layout: post
title: "浏览器是如何工作的(七)"
date: 2011-12-11 15:13
comments: true
categories: browsers
---
4.1 渲染树和DOM树的关系

renderer对应于DOM的元素，但并不是一对一的关系。非视觉DOM元素不会被插入渲染树，比如”head”元素。元素的视觉属性是"none"的元素不会出现在树中(视觉属性是”hidden”话会出现在树中)。

DOM元素对应多个视觉对象。一般情况下，复杂结构的元素不能在单个矩形中被描述清楚。比如，`select`元素有3个renderer：一个是显示区域；一个是下拉框；还有一个是按钮。当文字被分成多行的时候(在一行里显示的宽度不够)，新的行会被作为附加renderer加入到树中。

另一个有许多renderer的例子例子是不完整的HTML。根据CSS规范，内联元素必须包含块元素或着只包含内联元素。为了防止混合的内容，匿名块renderer会被创建来包裹内敛元素。

有些渲染对象对应于DOM节点，但不是在树中的相同位置。浮动元素和绝对固定位置的元素会被放置在树中的不同的位置，而且映射到实际的frame中去，所以它应该是有站位符的frame。

<!-- more -->

![render tree corresponding dom tree](http://farm8.staticflickr.com/7156/6486727487_c447bed064.jpg" width="500" height="271")

4.2 构造树的流程

在Firefox中，展示层为了DOM更新而注册成了一个监听器。展示层把frame的创建代理给了`FrameConstructor`，而且构造器处理样式和创建frame。

在Webkit中，处理样式和创建renderer被称为“attachment”。每个DOM节点都有一个”attach”方法。“attachment”是同步的，节点被添加到DOM树中被称为新节点”attach”方法。

处理html和body标签会造成渲染树根节点的构造。根渲染对象对应于在CSS规范中的containing block(最上端包含其他所有block的block)。跟节点的大小就是viewport(浏览器窗口显示的区域大小)，Firefox把它称作`ViewPortFrame`，而Webkit把它称为`RenderView`。这就是文档指向的渲染对象，树的其余部分是通过插入DOM节点来构造的。

4.3 样式的计算

构建渲染树的时候需要计算渲染对象的视觉属性，这是通过计算每个元素的style属性完成的。

样式包括各种样式表源，内联样式元素和HTML里的视觉属性(比如”bgcolor”属性)，然后再被转换匹配CSS里的属性。

样式表源是浏览器的默认样式表，样式表由开发者和用户样式表提供。用户样式表是由浏览器使用者提供(浏览器允许自定义样式，比如在Firefox中，可以通过在"Firefox Profile"文件夹下放置样式表来实现)。

样式的计算有一些难点：

1. 样式数据结构非常庞大，持有大量的样式属性会有内存问题。
2. 为每个元素找到对应的规则在没有优化的情况下会有性能问题。为每个元素遍历整个规则表是一个非常繁重的工作。选择器的结构有的非常负责，这会造成匹配过程从一个看上去有希望的路径开始，但最后证明是无效的，然后尝试另一个路径。

      例如下面这个组合选择器：

       div div div div{
       ...
       }
      
      上面例子的样式意味着要应用到一个被3个div包含的`<div>`上去。假如你想检查这个规则被应用到了一个给定的div元素上，你需要选择某个路径向上查找。你可能会向上遍历节点树，发现只有2个div元素，然后尝试另一条路径。

3. 应用规则包括非常复杂的层级规则，它定义了规则的继承关系。

让我们来看一下浏览器是怎么处理这些问题的：

4.3.1 共享样式数据

Webkit的节点引用样式对象(RenderStyle)，这些对象可以在某些条件下被节点共享。这些节点是兄弟或同辈节点，而且：

1. 元素必须在相同的鼠标状态下(比如，一个有`:hover`而另一个没有)
2. 两个元素都不应该有id
3. 标签名要匹配
4. `class`属性要匹配
5. 映射过的属性要一致
6. `link`要匹配
7. `focus`要匹配
8. 两个元素都不能被属性选择器影响，影响的是定义为拥有任何选择器匹配使用一个属性的选择器。
9. 元素没有内联样式属性
10. 必须有兄弟选择器，当遇到任何的兄弟选择器，WebCore简单的抛出一个全局switch，当他们出现时对整个文档禁用样式共享。这包括`+`选择器和`:first-child`，`:last-child`选择器。

4.3.2 Firefox规则树

为了更简单地计算样式，Firefox有两个额外的树：规则树和样式上下文树。Webkit也有样式对象，不过他们都不保存在树中，只有DOM节点指向与它相关的样式。

![style context tree](http://farm8.staticflickr.com/7031/6490768261_6bb541748b.jpg" width="500" height="318")

样式上下文树包含最终值。这个值是通过应用在正确顺序上的所有匹配的规则和把逻辑值转换成具体的值。比如，如果逻辑值是屏幕的百分比，那它会被计算和转换成绝对值。规则树的想法真的是非常聪明，它使得在节点间共享这些值，避免了再次的计算，也节省了空间。

所有匹配的规则被保存在一个树中，叶子节点在路径上有更高的优先级。这棵树包含所有已经找到并且匹配的路径。规则是延迟保存的，这棵树不会在一开始为每个节点计算，只是当一个节点的样式需要被计算时，计算路径才会被加入到树中。

这个查找路径的想法就像在字典中查单词一样，让我看一下已经计算好的规则树：

![rule tree](http://farm8.staticflickr.com/7152/6490816137_053bb01868.jpg" width="400" height="261")

假设我们需要为一个上下文树中的元素匹配规则，并且找到了匹配的规则是B - E - I。我们已经在树中有这个路径，因为我们已经计算了路径A - B - E - I - L，所以现在剩下的工作变得轻松很多。

让我看一下这棵树是怎么减轻我们的工作量的。

分配成为结构(Division into structs)

样式上下文被分配成为结构。这些结构包含了某个种类的样式信息，比如`border`或`color`。所有的属性在结构中要么被继承，要么没有被继承。继承的属性除非是被元素定义，否则继承自他的父亲。没有继承的属性(被称为”reset”属性)在某有定义的情况下使用默认值。

这棵树的作用是缓存树中的整个结构(包含计算完成的最终值)。这个想法就是，如果底端的节点不能满足一个结构的定义，那么就可以使用缓存结构中更上层的节点。

用规则树计算样式上下文

当为某个元素计算样式上下文时，我们首先计算规则树中的一个路径，或者使用现有的一个路径。然后开始应用路径上的规则来填充新样式上下文的结构。我们从路径的底部节点开始(最高的优先级，通常是最具体的选择器)向上遍历整棵树直到结构被填充满。如果在规则节点中没有结构的规范，我们就可以做巨大的优化(向上遍历树直到找到一个完全匹配的节点，然后简单地指向它，这是最优优化，因为整个结构被共享了，节省计算最终值的工作量和内存）。

如果只找到部分定义就向上查找知道结构被填满。

如果没有找到对结构的任何定义，为了防止结构是一个继承类型，就把它指向上下文树的双亲结构，在这种情况下我们也能共享结构，如果是一个reset结构，那么将会使用默认值。

如果大多数特定的节点加入了值，我们需要做一些额外的计算把它转换成实际值，然后在缓存结果在树节点中，然后就可以被子节点使用。

为了防止一个元素有兄弟，把它指向同一个节点，这样的话整个样式上下文可以被他们共享。

让我看个例子，假设有下面的HTML

{% codeblock lang:html %}
<html>
  <body>
    <div class="err" id="div1">
      <p>
        this is a <span class="big"> big error </span>
        this is also a
        <span class="big"> very  big  error</span> error
      </p>
    </div>
    <div class="err" id="div2">another error</div>
  </body>
</html>
{% endcodeblock %}

和下面的规则：

{% codeblock %}
1. div {margin:5px;color:black}
2. .err {color:red}
3. .big {margin-top:3px}
4. div span {margin-bottom:4px}
5. #div1 {color:blue}
6. #div2 {color:green}
{% endcodeblock %}

为了简便，我们之需要填充两个结构：`color`和`margin`结构。`color`结构只包含一个成员`color`；`margin`结构包含四个方面。

规则树的结果大致是下面的样子(节点用节点名标记，#号后的数字是它指向的规则)：

![rule tree](http://farm8.staticflickr.com/7163/6490941481_7c897aeef6.jpg" width="500" height="294")

上下文树则是下面的的样子(冒号后的是它指向的规则节点)：

![context tree](http://farm8.staticflickr.com/7172/6490949269_a4116c1fd5.jpg" width="400" height="305")

假设解析HTML而且要得到第二个`div`标签，我们需要为这个节点创建一个样式上下文，然后填充它的样式结构。

匹配规则后发现与这个`div`匹配的规则是1，2和6。这意味着在树中已经有一个存在的路径供我们的元素使用，只要加入另一个节点6到规则树中(规则树的节点F)。

我们将会创建一个样式上下文，并把它加入到上下文树中，新的样式上下文将指向规则树的节点F。

现在需要填充样式结构了。我们从填充`margin`结构开始，因为最后的规则节点F没有加入到`margin`结构，我们向上查找节点直到找到在上一次节点插入是已经缓存的计算完成的结构，然后使用这个结构。这个节点就是B，它是`margin`规则的最上层节点。

我们有一个`color`结构的定义，所以我们不能使用缓存的结构。因为`color`有一个属性，所以不需要向上查找节点填充其他属性。我们只要计算最终值(把字符串转换成RGB等)，并且缓存这个节点的结构。

第二个`span`元素的工作更容易。匹配规则的结果是像前一个`span`一样指向G。因为我们有兄弟节点指向相同节点，我们可以共享整个样式上下文，只需要指向上一个`span`的上下文。

对于包含继承它双亲的规则的结构来说，缓存是在上下文树中完成的。(`coloor`属性是被继承的，但是Firefox把它当作reset，缓存在规则树上)。

例如，如果我们在一个段落里加入字体规则：

{% codeblock %}
p {font-family:Verdana;font size:10px;font-weight:bold} 
{% endcodeblock %}

段落元素是上下文树中`div`节点的孩子节点，所以如果段落没有定义字体规则的情况下，可以共享它双亲相同的字体结构。

Webkit没有规则树，所以匹配的定义要遍历4次。首先是非重要高优先级属性先于高优先级重要属性(被其他的属性依赖的属性先要被生成节点，比如`display`)被生成节点。然后一般优先级非重要属性，再是一般优先级重要属性。这意味着出现多次的属性会被处理多次，但是结果由最后一次决定。

所以总结来说：共享样式对象(全部或者部分结构)可以解决问题1和3。Firefox的规则树则会帮助在正确的顺序下应用属性。

