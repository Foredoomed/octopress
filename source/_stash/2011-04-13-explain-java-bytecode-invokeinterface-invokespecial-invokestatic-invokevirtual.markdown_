---
layout: post
title: "Java字节码invokeinterface,invokespecial,invokestatic和invokevirtual的含义和区别"
date: 2011-04-13 19:13
comments: true
categories: java
---
在解释之前，首先需要理解JVM中的两个数据结构：**Frames(栈帧)**和**Operand Stack(操作数栈)**。

**栈帧**

在JVM中，栈帧是用来保存数据和部分结果，执行动态链接，返回方法调用的结果，分发异常。

每一次当一个方法被调用时就会创建一个新的栈帧，并且栈帧会在方法调用完毕后(无论方法是否正常执行结束或者因未捕获的异常而终止)消亡。

栈帧是由JVM中创建栈帧的线程分配的。每个栈帧里含有：他自己的本地变量(基本数据类型或引用类型)的数组，他自己的操作数栈和一个当前方法所在类的常量池的引用。

本地变量数组和操作数栈的大小在编译的时候就已经决定了，并且一直提供给和栈帧关联的方法使用。因此，栈帧的大小只跟JVM的实现以及方法被调用时这些数据结构同时在内存中被分配的大小决定。

在一个线程执行过程中，任何时候只有一个栈帧(也就是正在执行的方法的栈帧)处于活动状态。这个栈帧就被认为是当前栈帧，并且他包含的方法就是当前正在执行的方法。当前方法所在的类称为当前类。在本地变量和操作数栈上的操作都含有当前栈帧的引用。

当栈帧的方法调用另外的方法或者他的方法完成了，那么当前栈帧就会停止。当一个方法被调用的时候，会创建一个新的栈帧，并且当新的方法获得CPU控制权时这个新创建的栈帧会变成当前栈帧，当方法返回的时候，当前栈帧传回他的方法调用的结果，如果这个结果有的话将被传递给前一个栈帧。当之前的一个栈帧变成当前栈帧的时候，当前栈帧就会被丢弃。 <!--more-->

**操作数栈**

每个栈帧都有一个last-in-first-out(LIFO)的栈，这个栈就被称为操作数栈。操作数栈的最大深度在编译时就已经确定，并且供与这个栈帧相关联的方法使用。

当栈帧被创建时，操作数栈是空的。JVM发出指令装载本地变量中的常量和值到操作数栈中去。另外的指令是从操作数栈中取数，运算完成后把结果再放入操作数栈中。操作数栈还被用来保存方法的参数和方法的返回值。

操作数栈中的值都是一个Java基本类型或者引用类型。操作数栈中的值必须在适合他们的类型的方式下操作。一小部分JVM指令(dup，swap)执行时不考虑值的类型，这些指令不能修改和分开单个的值，这些操作数栈的限制通过类文件检查时强制执行。

long和double类型在操作数栈有2个单元长度，其他类型都是1个单元长度。

**invokeinterface**

当调用接口中的方法的时候，就会使用invokeinterface指令。

Operand Stack
    ..., objectref, [arg1, [arg2 ...]]  ...

实际被调用的方法将会遵循下面的查找步骤：

(1)如果objectref这个类中含有和将要被调用的方法有相同的方法名和参数的方法，那么objectref这个类中的方法将会被调用，并且查找过程结束。

(2)如果经过(1)后没有找到合适的方法，并且如果objectref有父类的话，那么就会在他的父类里迭代执行。

(3)如果(1)，(2)后都没有找到，则会抛出AbstractMethodError。

**invokespecial**

当调用类的任何构造方法时，就会使用invokespecial指令。

Operand Stack
    ..., objectref, [arg1, [arg2 ...]]  ...

如果将要被调用的构造方法是“protected”的，并且要么是当前类的成员，要么是当前类父类的成员，那么objectref必须要么是当前类，要么是当前类的子类。

当下面的条件都为“true”时，才会调用方法：

(1)当前类已经设置好ACC_SUPER标志位。

(2)要调用构造方法所在的类是当前类的父类。

(3)要调用的构造方法所在的类还没有被实例化。

当上面的条件都为“true”时，实际将要被调用的方法将会遵循下面的查找步骤。(假定C是当前类的直接父类):

(1)如果C中有声明过相同的方法(包括方法签名和参数)，那么这个方法将会被调用，并且查找过程结束。

(2)如果(1)不满足，并且C有父类，那么会在C的父类中迭代(1)，实际被调用的方法就是这个迭代查找过程的结果，并且查找过程结束。

(3)如果(1),(2)都不满足，将会抛出AbstractMethodError。

**invokestatic**

当调用类的静态方法时，就会使用invokestatic指令。

Operand Stack
    ..., [arg1, [arg2 ...]]  ...

被调用的方法必须是静态方法，而且不能是抽象方法，并且如果要使用类的属性的话，那么类的属性也必须是静态的。

如果这个静态方法是synchronized的，那么需要获得与这个类相关的monitor。

如果这个被调用的方法不是native的话，操作数栈里保存的参数将会被弹出，并且为这个方法创建一个新的栈帧，弹出的参数按顺序赋值给新创建的栈帧的本地变量。如果弹出的参数是浮点类型的值的话，那么在保存为新栈帧的本地变量之前将会被类型转型(转换为最接近这个浮点类型值的类型)。

**invokevirtual**

当调用类的实例方法时，就会使用invokevirtual指令。

值得注意的是，Java中的所有实例方法默认都是virtual的。

Operand Stack
    ..., objectref, [arg1, [arg2 ...]]  ...

如果被调用的方法是protected，并且他要么是当前类的成员，要么是当前类的父类里的成员，那么objectref必须要么是当前类，要么是当前类的子类。

实际被调用的方法将会遵循以下查找过程：

(1)如果objectref中有相同方法签名和参数的方法，并且这个方法可以从objectref中访问到，那么这个方法就会被调用，并且查找过程结束。

(2)如果(1)不满足，并且objectref有一个父类，那么会在父类中迭代(1)，实际被调用的方法就是这个迭代查找过程的结果，并且查找过程结束。

(3)如果(1),(2)都不满足，将会抛出AbstractMethodError 。

